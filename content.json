{"meta":{"title":"AeonJh’s Blog","subtitle":"","description":"非学无以广才，非志无以成学!","author":"AeonJh","url":"https://aeonjh.top","root":"/"},"pages":[{"title":"文章归档","date":"2023-05-14T14:50:25.309Z","updated":"2023-05-14T14:50:25.309Z","comments":true,"path":"archive.html","permalink":"https://aeonjh.top/archive","excerpt":"","text":""},{"title":"关于","date":"2023-05-14T16:00:00.000Z","updated":"2023-05-15T09:54:41.217Z","comments":true,"path":"about.html","permalink":"https://aeonjh.top/about","excerpt":"","text":"慢慢走，比较快。 作品 正在赶来的路上······"},{"title":"年度书单","date":"2023-05-15T10:15:54.074Z","updated":"2023-05-15T10:15:54.074Z","comments":true,"path":"book.html","permalink":"https://aeonjh.top/book","excerpt":"","text":""},{"title":"","date":"2023-05-14T14:59:03.921Z","updated":"2023-05-14T14:59:03.921Z","comments":true,"path":"custom.css","permalink":"https://aeonjh.top/custom.css","excerpt":"","text":":root { --gutter: 25px; --radius: 13px; --color-primary: #ff4e6a; --color2: #ff761e; --color3: #ffb900; --color4: #33d57a; --color5: #00dbff; --color6: #1a98ff; --color7: #9090ff; --color-primary-bg: rgba(255,78,106,0.15); --color2-bg: rgba(255,118,30,0.15); --color3-bg: rgba(255,185,0,0.15); --color4-bg: rgba(51,213,122,0.15); --color5-bg: rgba(0,219,255,0.15); --color6-bg: rgba(26,152,255,0.15); --color7-bg: rgba(144,144,255,0.15); --color-shadow: rgba(161, 177, 204, 0.4); }"}],"posts":[{"title":"从零开始的JSON库学习","slug":"从零开始的JSON库学习","date":"2023-05-30T10:35:20.000Z","updated":"2023-05-30T10:35:20.000Z","comments":true,"path":"2023/05/30/从零开始的JSON库学习/","link":"","permalink":"https://aeonjh.top/2023/05/30/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%9A%84JSON%E5%BA%93%E5%AD%A6%E4%B9%A0/","excerpt":"","text":"从零开始的JSON库学习 本文章主要记录一下学习叶劲峰老师的开源JSON库leptjsonmiloyip/json-tutorial: 从零开始的 JSON 库教程的过程及总结。本文中只给出部分代码示例，完整源代码请到lept_study查看。 一、JSON介绍、相关开发手段及理念JSON（JavaScript Object Notation）是一个用于数据交换的文本格式，例如： 123456789101112131415161718&#123; &quot;title&quot;: &quot;Design Patterns&quot;, &quot;subtitle&quot;: &quot;Elements of Reusable Object-Oriented Software&quot;, &quot;author&quot;: [ &quot;Erich Gamma&quot;, &quot;Richard Helm&quot;, &quot;Ralph Johnson&quot;, &quot;John Vlissides&quot; ], &quot;year&quot;: 2009, &quot;weight&quot;: 1.8, &quot;hardcover&quot;: true, &quot;publisher&quot;: &#123; &quot;Company&quot;: &quot;Pearson Education&quot;, &quot;Country&quot;: &quot;India&quot; &#125;, &quot;website&quot;: null&#125; 可以看出，JSON是树状结构，而JSON只包含 6 种数据类型： null: 表示为 null boolean: 表示为true 或 false number: 一般的浮点数表示方式，在下一单元详细说明 string: 表示为 &quot;...&quot; array: 表示为 [ ... ] object: 表示为 &#123; ... &#125; 要实现的json库，需求如下： 把 JSON 文本解析为一个树状数据结构（parse）。 提供接口访问该数据结构（access）。 把数据结构转换成 JSON文本（stringify）。 1.1 JSON 语法子集下面是JSON语法子集，使用 RFC7159 中的 ABNF 表示： 1234567891011121314151617181920212223242526272829303132333435363738JSON-text: ws value ws ws = *(%x20 / %x09 / %x0A / %x0D) value = null / false / true null = &quot;null&quot; false = &quot;false&quot; true = &quot;true&quot; value = number number = [ &quot;-&quot; ] int [ frac ] [ exp ] int = &quot;0&quot; / digit1-9 *digit frac = &quot;.&quot; 1*digit exp = (&quot;e&quot; / &quot;E&quot;) [&quot;-&quot; / &quot;+&quot;] 1*digit value = string string = quotation-mark *char quotation-mark char = unescaped / escape ( %x22 / ; &quot; quotation mark U+0022 %x5C / ; \\ reverse solidus U+005C %x2F / ; / solidus U+002F %x62 / ; b backspace U+0008 %x66 / ; f form feed U+000C %x6E / ; n line feed U+000A %x72 / ; r carriage return U+000D %x74 / ; t tab U+0009 %x75 4HEXDIG ) ; uXXXX U+XXXX escape = %x5C ; \\ quotation-mark = %x22 ; &quot; unescaped = %x20-21 / %x23-5B / %x5D-10FFFF value = array array = %x5B ws [ value *( ws %x2C ws value ) ] ws %x5D %x5B = [ %x2C = , %x5D = ] value = object object = %x7B ws [ member *( ws %x2C ws member ) ] ws %x7D member = string ws %x3A ws value %x7B = &#123; %x3A = : %x7D = &#125; 1.2 单元测试测试驱动开发（Test-Driven Development，TDD）是一种软件开发方法论，它要求在编写代码之前先编写测试用例，然后编写代码以使这些测试用例能够通过。 测试驱动开发的实施过程： 为需要实现的新功能添加一批测试； 运行所有测试，看看新添加的测试是否失败； 编写实现软件新功能的实现代码； 再次运行所有的测试，看是否有测试失败； 重构代码； 重复以上步骤直到所有测试通过。 1.3 宏的编写技巧反斜线代表该行未结束，会串接下一行。而如果宏里有多过一个语句（statement），就需要用do &#123; /**...**/ &#125; while(0)包裹成单个语句。 123456789101112131415#define M()\\ do &#123; a(); b(); &#125;\\ while(0)if (cond) M();else c();/* 预处理后 */if (cond) do &#123; a(); b(); &#125; while(0);else c(); 1.4 断言（assertion）C 语言的标准库含有assert()这个宏（需#include），提供断言功能。当程序以release配置编译时（定义了NDEBUG宏），assert()不会做检测；而当在debug配置时（没定义NDEBUG宏），则会在运行时检测assert(conditional)中的条件是否为真（非 0），断言失败会直接令程序崩溃。 另一个问题是，初学者可能会难于分辨何时使用断言，何时处理运行时错误（如返回错误值或在 C++ 中抛出异常）。简单的答案是，如果那个错误是由于程序员错误编码所造成的（例如传入不合法的参数），那么应用断言；如果那个错误是程序员无法避免，而是由运行时的环境所造成的，就要处理运行时错误（例如开启文件失败）。 1.5 union另外，由于项目中使用了匿名union，此特性是C11版本之后新加入的，需要在CMakeLists.txt中指定C标准版本： 1set(CMAKE_C_STANDARD 11) 1.6 内存泄露检测配置我们可以使用 valgrind （Linux / OS X）工具来检测内存泄漏问题，这里我选择的方案是在CLion配置编译环境为WSL2，配置如下： 另外由于使用的clang版本过新（我使用的是14.0.0）会导致使用Valgrind时报以下错误信息： 1234### unhandled dwarf2 abbrev form code 0x25### unhandled dwarf2 abbrev form code 0x25### unhandled dwarf2 abbrev form code 0x25### unhandled dwarf2 abbrev form code 0x1b 改用gcc编译或者在CMakeLists.txt中加入以下编译选项后，重新加载CMakeLists.txt即可。 12target_compile_options(leptjson PRIVATE -gdwarf-4)target_compile_options(leptjson_test PRIVATE -gdwarf-4) 二、数据结构在本次开发中共涉及两个主要步骤，一是解析传入的json文本为树形数据结构，二是生成相应的json文本，因此采用结构体类型存储过程值与结果值，同时定义相关的类型值与状态值（enum类型有利于更直观的表达相应的类型与状态）：typedef enum &#123; ··· &#125; lept_type;、enum &#123; LEPT_PARSE_OK = 0&#125;。 存储解析得到的值用结构体lept_value表示（各数据类型都已作相关说明）： 1234567891011121314151617181920212223242526struct lept_value &#123;/* union: a variable that can be used to store different types of data atdifferent times Anonymous unions are a C11 extension. */ union &#123; /* string */ /* s: string */ /* len: string&#x27;s length */ struct &#123; char* s; size_t len; &#125;s; /* array */ /* e: element */ /* size: array&#x27;s size */ /* capacity: array&#x27;s capacity */ /* array: dynamic array */ /* The capacity is added here to better support operations on arrays, such as: add or delete elements */ /* The capacity is the size of the array, and the size is the number of elements in the array. */ struct &#123; lept_value* e; size_t size, capacity; &#125;a; /* object */ /* m: member */ /* size: object&#x27;s size */ /* capacity: object&#x27;s capacity */ /* object: dynamic array */ struct &#123; lept_member* m; size_t size, capacity; &#125;o; double n; /* number */ &#125;; lept_type type; /* value type */&#125;;struct lept_member &#123; char* k; size_t klen; /* member key string, key string&#x27;s length */ lept_value v; /* member value */&#125;; 在解析和生成json文本的过程中，需要将输入输出数据存储到临时的缓冲区，以提高性能和简化实现。由于在解析过程中，这个缓冲区的大小是不能预知的。因此，我们可以采用动态数组（dynamic array）来实现： 123456typedef struct &#123; const char* json; /* input output buffers (dynamic stack) */ char* stack; size_t size, top;&#125; lept_context; 当中size是当前的堆栈容量，top是栈顶的位置（由于stack是可拓展的，所以不要用指针形式存储top）。 三、解析3.1 主要解析步骤对于解析部分，我们采用lept_parse()函数实现： 12345678910111213141516171819202122232425262728int lept_parse(lept_value* v, const char* json) &#123; lept_context c; /* can be used to check the parse result */ int ret; assert(v != NULL); /* initialize lept_context */ c.json = json; c.stack = NULL; c.size = c.top = 0; /* initialize lept_value */ lept_init(v); /* parse whitespace */ lept_parse_whitespace(&amp;c); /* parse the first character */ if ((ret = lept_parse_value(&amp;c, v)) == LEPT_PARSE_OK) &#123; /* parse the next character */ lept_parse_whitespace(&amp;c); /* if the next character is not &#x27;\\0&#x27;, then the json string is not over */ if (*c.json != &#x27;\\0&#x27;) &#123; v-&gt;type = LEPT_NULL; ret = LEPT_PARSE_ROOT_NOT_SINGULAR; &#125; &#125; /* free the memory of lept_context */ assert(c.top == 0); free(c.stack); return ret;&#125; 我们根据JSON语法格式JSON-text: ws value ws处理传入的json文本，注意对相应的变量（尤其是指针）做好初始化及释放工作。由上述函数可见，我们采用lept_parse_value()对缓冲区的数据进行解析，源代码如下： 123456789101112static int lept_parse_value(lept_context* c, lept_value* v) &#123; switch (*c-&gt;json) &#123; case &#x27;n&#x27;: return lept_parse_literal(c, v, &quot;null&quot;, LEPT_NULL); case &#x27;f&#x27;: return lept_parse_literal(c, v, &quot;false&quot;, LEPT_FALSE); case &#x27;t&#x27;: return lept_parse_literal(c, v, &quot;true&quot;, LEPT_TRUE); case &#x27;&quot;&#x27;: return lept_parse_string(c, v); case &#x27;[&#x27;: return lept_parse_array(c, v); case &#x27;&#123;&#x27;: return lept_parse_object(c, v); case &#x27;\\0&#x27;: return LEPT_PARSE_EXPECT_VALUE; default: return lept_parse_number(c, v); &#125;&#125; 3.2 相关函数拆解我们选取其中解析字符串的函数lept_parse_string()进行介绍。 12345678910static int lept_parse_string(lept_context* c, lept_value* v) &#123; int ret; char* s; size_t len; /* parse string */ if ((ret = lept_parse_string_raw(c, &amp;s, &amp;len)) == LEPT_PARSE_OK) &#123; lept_set_string(v, s, len); &#125; return ret;&#125; 因为在后续对object类型解析的过程中，object的key属性为string类型，我们可以选择重构原来的字符串类型解析函数，提取出lept_parse_string_raw()函数，使得它既可以被字符串类型解析调用，又可以被object解析key时调用。 在解析字符串值时，最需要注意的便是对转义字符的处理，我们采用之前提到的缓冲区（采用dynamic array实现）来解决此问题。为了更好的实现对缓冲区的操作，我们实现堆栈的压入及弹出操作： 123456789101112131415161718192021222324252627282930/* return the memory address of the top of the stack */static void* lept_context_push(lept_context* c, size_t size) &#123; /* check the stack size */ assert(size &gt; 0); void* ret; /* check the stack size */ if (c-&gt;top + size &gt;= c-&gt;size) &#123; /* double the stack size */ if (c-&gt;size == 0) &#123; c-&gt;size = LEPT_PARSE_STACK_INIT_SIZE; &#125; while (c-&gt;top + size &gt;= c-&gt;size) &#123; c-&gt;size += c-&gt;size &gt;&gt; 1; /* c-&gt;size * 1.5 */ &#125; /* allocate memory */ c-&gt;stack = (char*)realloc(c-&gt;stack, c-&gt;size); &#125; /* returns the memory address of the top of the stack */ ret = c-&gt;stack + c-&gt;top; /* update the top of the stack */ c-&gt;top += size; return ret;&#125;/* pop characters from the stack */static void* lept_context_pop(lept_context* c, size_t size) &#123; assert(c-&gt;top &gt;= size); /* returns the memory address of the pop-up value and update the top of the stack */ return c-&gt;stack + (c-&gt;top -= size);&#125; 实现以后为了简化代码，我们将压入单个字符与整块字符抽象为两个宏定义： 12#define PUTC(c, ch) do &#123; *(char*)lept_context_push(c, sizeof(char)) = (ch); &#125; while(0)#define PUTS(c, s, len) memcpy(lept_context_push(c, len), s, len) 接下来我们来看一下lept_parse_string_raw()的实现： 1234567891011121314151617181920212223242526272829303132333435363738394041424344static int lept_parse_string_raw(lept_context* c, char** str, size_t* len) &#123; /* ··· */ for (;;) &#123; /* ··· */ case &#x27;\\\\&#x27;: switch (*p++) &#123; /* ··· */ case &#x27;u&#x27;: /* validate the 4 hexadecimal digits */ if (!(p = lept_parse_hex4(p, &amp;u))) STRING_ERROR(LEPT_PARSE_INVALID_UNICODE_HEX); /* check the high surrogate */ if (u &gt;= 0xD800 &amp;&amp; u &lt;= 0xDBFF) &#123; /* validate the low surrogate */ if (p[0] == &#x27;\\\\&#x27; &amp;&amp; p[1] == &#x27;u&#x27;) &#123; /* skip &#x27;\\u&#x27; */ p += 2; if (!(p = lept_parse_hex4(p, &amp;u2))) STRING_ERROR(LEPT_PARSE_INVALID_UNICODE_HEX); if (u2 &lt; 0xDC00 || u2 &gt; 0xDFFF) STRING_ERROR(LEPT_PARSE_INVALID_UNICODE_SURROGATE); /* calculate the code point */ /* codepoint = 0x10000 + (H − 0xD800) × 0x400 + (L − 0xDC00) */ u = (((u - 0xD800) &lt;&lt; 10) | (u2 - 0xDC00)) + 0x10000; &#125; else STRING_ERROR(LEPT_PARSE_INVALID_UNICODE_SURROGATE); &#125; /* encode the code point as utf8 */ lept_encode_utf8(c,u); break; /* ··· */ &#125; break; case &#x27;\\0&#x27;: STRING_ERROR(LEPT_PARSE_MISS_QUOTATION_MARK); default: /* check the character */ if ((unsigned char)ch &lt; 0x20) STRING_ERROR(LEPT_PARSE_INVALID_STRING_CHAR); /* push the character to the stack */ PUTC(c, ch); /* ··· */&#125; 其中最主要的即是关于转义字符及转义序列的处理，此处我们提取函数lept_parse_hex4()解析4位16进制数，对于基本多文种平面（basic multilingual plane, BMP）以外的字符，JSON会使用代理对（surrogate pair）表示 \\uXXXX\\uYYYY。在BMP中，保留了2048个代理码点。如果第一个码点是U+D800至U+DBFF，我们便知道它的代码对的高代理项（high surrogate），之后应该伴随一个 U+DC00 至 U+DFFF 的低代理项（low surrogate）。然后，我们用下列公式把代理对 (H, L) 变换成真实的码点： 1codepoint = 0x10000 + (H − 0xD800) × 0x400 + (L − 0xDC00) 转换成C代码即： 1u = (((u - 0xD800) &lt;&lt; 10) | (u2 - 0xDC00)) + 0x10000; 对于处理后得到的码点，我们对它进行UTF-8编码。 码点范围 码点位数 字节1 字节2 字节3 字节4 U+0000 ~ U+007F 7 0xxxxxxx U+0080 ~ U+07FF 11 110xxxxx 10xxxxxx U+0800 ~ U+FFFF 16 1110xxxx 10xxxxxx 10xxxxxx U+10000 ~ U+10FFFF 21 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx 函数实现也很简单，只需要做相应的位操作就行。 12345678910111213141516171819202122232425static void lept_encode_utf8(lept_context* c, unsigned u) &#123; /* 1 byte */ if (u &lt;= 0x7F) &#123; PUTC(c, u &amp; 0xFF); &#125; /* 2 bytes */ else if (u &lt;= 0x7FF) &#123; PUTC(c, 0xC0 | ((u &gt;&gt; 6) &amp; 0xFF)); PUTC(c, 0x80 | ( u &amp; 0x3F)); &#125; /* 3 bytes */ else if (u &lt;= 0xFFFF) &#123; PUTC(c, 0xE0 | ((u &gt;&gt; 12) &amp; 0xFF)); PUTC(c, 0x80 | ((u &gt;&gt; 6) &amp; 0x3F)); PUTC(c, 0x80 | ( u &amp; 0x3F)); &#125; /* 4 bytes */ else &#123; assert(u &lt;= 0x10FFFF); PUTC(c, 0xF0 | ((u &gt;&gt; 18) &amp; 0xFF)); PUTC(c, 0x80 | ((u &gt;&gt; 12) &amp; 0x3F)); PUTC(c, 0x80 | ((u &gt;&gt; 6) &amp; 0x3F)); PUTC(c, 0x80 | ( u &amp; 0x3F)); &#125;&#125; 至此，有关于字符串的解析工作就已经全部完成。对于数组（array）和对象（object）的解析工作与字符串解析相差不大，需要注意的是在这两种数据类型的解析中我们会采用递归下降解析器（recursive descent parser）进行处理。在数组解析中我们采用leptvalue e创建一个临时变量来存储解析值，并在解析成功后将其压入栈中： 1memcpy(lept_context_push(c, sizeof(lept_value)), &amp;e, sizeof(lept_value)); 在对象解析中同样如此，只不过我们采用单独的成员结构体lept_member m来存储解析过程中间解析到的键char* k与对应的值lept_value v。 值得注意的是在解析完成后我们需要释放临时变量e与m malloc的内存空间： 1234567891011121314151617/* array *//* pop and free the elements on the stack */for (i = 0; i &lt; size; i++) lept_free((lept_value*)lept_context_pop(c, sizeof(lept_value)));/* ··· *//* object *//* free the key */free(m.k);/* pop and free the members on the stack */for (i = 0; i &lt; size; i++) &#123; lept_member* mf = ((lept_member*)lept_context_pop(c, sizeof(lept_member))); free(mf-&gt;k); lept_free(&amp;mf-&gt;v);&#125;v-&gt;type = LEPT_NULL; 同样，在完成整个JSON解析过程后，我们需要对手动malloc的内存空间进行释放，我们实现一个lept_free()函数，同样是采用分类+递归的方法进行内存释放。 12345678910111213141516171819202122232425262728void lept_free(lept_value* v) &#123; assert(v != NULL); size_t i; /* free the memory */ switch (v-&gt;type) &#123; case LEPT_STRING: free(v-&gt;s.s); break; case LEPT_ARRAY: /* free the memory of each element */ for (i = 0; i &lt; v-&gt;a.size; i++) lept_free(&amp;v-&gt;a.e[i]); /* free the memory of the array */ free(v-&gt;a.e); break; case LEPT_OBJECT: /* free the memory of each member */ for (i = 0; i &lt; v-&gt;o.size; i++) &#123; free(v-&gt;o.m[i].k); lept_free(&amp;v-&gt;o.m[i].v); &#125; /* free the memory of the object */ free(v-&gt;o.m); break; default: break; &#125; v-&gt;type = LEPT_NULL;&#125; 整个解析流程的主要步骤就是以上这些。对于提供给外部访问的API函数，我们同样分别加以实现，此处对于简单的获取类型（或值），设置类型等函数不在详述，主要分析一下有关于赋值操作的三个函数lept_move()、lept_swap()、lept_copy()。对于移动赋值和交换赋值来讲，实现的步骤也很简单，直接看代码： 1234567891011121314151617181920void lept_move(lept_value* dst, lept_value* src) &#123; assert(src != NULL &amp;&amp; dst != NULL &amp;&amp; src != dst); /* free the memory of dst */ lept_free(dst); /* move the memory of src to dst */ memcpy(dst, src, sizeof(lept_value)); /* reset the type of src to null */ lept_init(src);&#125;void lept_swap(lept_value* lhs, lept_value* rhs) &#123; assert(lhs != NULL &amp;&amp; rhs != NULL); /* swap the memory of lhs and rhs by using a temporary variable */ if (lhs != rhs) &#123; lept_value temp; memcpy(&amp;temp, lhs, sizeof(lept_value)); memcpy(lhs, rhs, sizeof(lept_value)); memcpy(rhs, &amp;temp, sizeof(lept_value)); &#125;&#125; 而对于拷贝赋值操作来说，我们需要考虑其他因素，因此，我们采用与lept_free()相同操作（分类+递归）进行实现： 12345678910111213141516171819202122232425262728293031323334353637383940void lept_copy(lept_value* dst, const lept_value* src) &#123; size_t i; assert(src != NULL &amp;&amp; dst != NULL &amp;&amp; src != dst); /* copy to dst according to different types */ switch (src-&gt;type) &#123; case LEPT_STRING: lept_set_string(dst, src-&gt;s.s, src-&gt;s.len); break; case LEPT_ARRAY: /* initialize dst as an array */ dst-&gt;type = LEPT_ARRAY; dst-&gt;a.e = (lept_value*)malloc(sizeof(lept_value) * src-&gt;a.size); lept_reserve_array(dst, src-&gt;a.size); /* copy the elements by recursive call */ for (i = 0; i &lt; src-&gt;a.size; i++) lept_copy(&amp;dst-&gt;a.e[i], &amp;src-&gt;a.e[i]); dst-&gt;a.size = src-&gt;a.size; break; case LEPT_OBJECT: /* initialize dst as an object */ dst-&gt;type = LEPT_OBJECT; dst-&gt;o.m = (lept_member*)malloc(sizeof(lept_member) * src-&gt;o.size); lept_reserve_object(dst, src-&gt;o.size); /* copy the members */ for (i = 0; i &lt; src-&gt;o.size; i++) &#123; /* copy the key */ lept_set_string(&amp;dst-&gt;o.m[i].k, src-&gt;o.m[i].k, src-&gt;o.m[i].klen); /* copy the value */ lept_copy(&amp;dst-&gt;o.m[i].v, &amp;src-&gt;o.m[i].v); &#125; /* update the size of dst */ dst-&gt;o.size = src-&gt;o.size; break; default: /* free the memory of dst */ lept_free(dst); /* copy the value directly */ memcpy(dst, src, sizeof(lept_value)); &#125;&#125; 对于其中涉及到的lept_reserve_object()与lept_reserve_array()函数，是为了方便增删元素而引进了容量capacity的概念，这两个函数即是对capacity进行扩增的操作。 四、生成在完成解析任务后，我们还需要对解析到的值转换为JSON文本的功能，与解析过程类似，采用lept_stringify()与lept_stringify_value()函数实现，将待转换的值存入缓冲区中，全部完成转换后返回缓冲区c.stack的内存地址。 1234567891011121314char* lept_stringify(const lept_value* v, size_t* length) &#123; lept_context c; assert(v != NULL); /* initialize lept_context */ c.stack = (char*)malloc(c.size = LEPT_PARSE_STRINGIFY_INIT_SIZE); c.top = 0; /* stringify the value */ lept_stringify_value(&amp;c, v); if (length) *length = c.top; /* add &#x27;\\0&#x27; to the end of the string */ PUTC(&amp;c, &#x27;\\0&#x27;); return c.stack;&#125; 五、测试跑通所有单元测试并解析json文件与文本生成，结果如下： 六、总结与收获在本次项目的开发中，学习到了许多，如：各种变量类型的合理使用（enum、union···），API函数的设计，TDD开发，static关键字的使用，宏的使用与编写技巧，断言（assert）的使用，内存管理 ··· 。 其中内存管理应该是最重要的知识点，从叶劲峰老师的动态数组建立缓冲区的操作中学到许多，及手动实现三种赋值操作，对于变量的内存概念进一步加深，以及对于内存释放lept_free()的实现。 本次项目虽然只是一个简单的JSON库的实现，却也包含了许多项目开发中需要注意到的细节，建议初学者学习。 本项目最后的生成实现上为了性能优化与代码简化，生成的是单行无缩进的文本，之后有时间学习了相关知识后可以尝试对其进行美化。 本篇文章到这里就结束了，如果你对本项目有兴趣，欢迎在评论区进行讨论！ 祝你好运^_^","categories":[{"name":"study","slug":"study","permalink":"https://aeonjh.top/categories/study/"}],"tags":[{"name":"JSON","slug":"JSON","permalink":"https://aeonjh.top/tags/JSON/"},{"name":"C","slug":"C","permalink":"https://aeonjh.top/tags/C/"}]},{"title":"Markdown基础语法学习","slug":"About the basic usage of Markdown","date":"2023-01-06T15:05:20.000Z","updated":"2023-05-14T14:55:20.000Z","comments":true,"path":"2023/01/06/About the basic usage of Markdown/","link":"","permalink":"https://aeonjh.top/2023/01/06/About%20the%20basic%20usage%20of%20Markdown/","excerpt":"","text":"这是AeonJh的第一篇博客，关于markdown语法的基础使用，本文仅供本人练习Markdown ! 如果是为了快速入手可以参考官网Markdown 语法速查表 | Markdown 官方教程 Markdown 标题语法 使用 #来创建标题，#的数量代表标题的级别。 因标题预览效果会导致目录自动添加，所以此处去除预览鲜果。 Markdown语法 HTML # Heading level 1 &lt;h1&gt;Heading level 1&lt;&#x2F;h1&gt; ## Heading level 2 &lt;h2&gt;Heading level 1&lt;&#x2F;h2&gt; ### Heading level 3 &lt;h3&gt;Heading level 1&lt;&#x2F;h3&gt; #### Heading level 4 &lt;h4&gt;Heading level 1&lt;&#x2F;h4&gt; ##### Heading level 5 &lt;h5&gt;Heading level 1&lt;&#x2F;h5&gt; ###### Heading level 6 &lt;h6&gt;Heading level 1&lt;&#x2F;h6&gt; 也可选用 ==号来创建一级标题，使用 -- 来创建二级标题。 Markdown 段落 使用空白行讲一行或多行文本进行分段 Markdown语法 HTML 预览效果 hello,world! tomorrow will be better! &lt;p&gt;hello,world!&lt;&#x2F;p&gt; &lt;p&gt;tomorrow will be better!&lt;&#x2F;p&gt; hello,world! tomorrow will be better! 注意： 请不要用空格（spaces）或者制表符（Tabs）对段落进行缩进 换行感觉不是那么重要，此处不再赘述。Markdown本身不提供单元格换行，但是，Markdown是兼容HTML的，因此，我们可以使用 &lt;br&gt; 来实现单元格换行。想获得更多信息可以自行查阅官网Markdown 换行语法 | Markdown 官方教程 Markdown 强调语法粗体（Bold） Markdown语法 HTML 预览效果 I love **bold text** . I love &lt;strong&gt;bold text&lt;&#x2F;strong&gt; . I love bold text . I love __bold text__ . I love &lt;strong&gt;bold text&lt;&#x2F;strong&gt; . I love bold text . Love**is**bold Love&lt;strong&gt;is&lt;&#x2F;strong&gt;bold Loveisbold Markdown 应用程序在如何处理单词或短语中间的下划线上并不一致。为兼容考虑，在单词或短语中间部分加粗的话，请使用星号（asterisks）(*) 斜体（Italic） Markdown语法 HTML 预览效果 I love *bold text* . I love &lt;em&gt;bold text&lt;&#x2F;em&gt; . I love bold text . I love _bold text_ . I love &lt;em&gt;bold text&lt;&#x2F;em&gt; . I love bold text . Loveis*bold* Loveis&lt;em&gt;bold&lt;&#x2F;em&gt; Loveisbold 粗体（Bold）和斜体（Italic） Markdown语法 HTML 预览效果 I love ***bold text*** . I love &lt;strong&gt;&lt;em&gt;bold text&lt;&#x2F;em&gt;&lt;&#x2F;strong&gt; . I love bold text . I love ___bold text___ . I love &lt;strong&gt;&lt;em&gt;bold text&lt;&#x2F;em&gt;&lt;&#x2F;strong&gt; . I love bold text . This love***is***bold This love&lt;strong&gt;is&lt;&#x2F;em&gt;&lt;&#x2F;strong&gt;bold This loveisbold Markdown 应用程序在处理单词或短语中间添加的下划线上并不一致。为了实现兼容性，请使用 星号 将单词或短语的中间部分加粗并以斜体显示，以示重要。 Markdown 引用语法 要创建块引用，请在段落前添加一个 &gt; 符号 1&gt; Dorothy followed her through many of the beautiful rooms in her castle. 效果如下： Dorothy followed her through many of the beautiful rooms in her castle. 多个段落块的引用 块引用可以包含多个段落。只需为段落之间的空白行添加一个 &gt; 符号。123&gt; Hello,world!&gt;&gt; I love you! 效果如下： Hello,world! I love you! 嵌套块引用123&gt; Hello,world!&gt;&gt;&gt; I love you! 效果如下： Hello,world! I love you! 带有其它元素的块引用 块引用可以包含其他 Markdown 格式的元素。并非所有元素都可以使用，你需要进行实验以查看哪些元素有效。12345&gt; #### Have a nice day!&gt;&gt; - This is a test.&gt;&gt; *Everything* is **going** according to ***plan***. 效果如下： Have a nice day! This is a test. Everything is going according to plan. Markdown 列表语法有序列表 要创建有序列表，请在每个列表项前添加数字并紧跟一个英文句点。数字不必按数学顺序排列，但是列表应当以数字 1 起始。 Markdown语法 HTML 预览效果 1. First item2. Second item3. Third item &lt;ol&gt;&lt;li&gt;First item&lt;&#x2F;li&gt;&lt;li&gt;Second item&lt;&#x2F;li&gt;&lt;li&gt;Third item&lt;&#x2F;li&gt;&lt;&#x2F;ol&gt; 1. First item2. Second item3. Third item 1. First item1. Second item1. Third item &lt;ol&gt;&lt;li&gt;First item&lt;&#x2F;li&gt;&lt;li&gt;Second item&lt;&#x2F;li&gt;&lt;li&gt;Third item&lt;&#x2F;li&gt;&lt;&#x2F;ol&gt; 1. First item2. Second item3. Third item 1. First item3.Second item2. Third item &lt;ol&gt;&lt;li&gt;First item&lt;&#x2F;li&gt;&lt;li&gt;Second item&lt;&#x2F;li&gt;&lt;li&gt;Third item&lt;&#x2F;li&gt;&lt;&#x2F;ol&gt; 1. First item2. Second item3. Third item 无序列表 要创建无序列表，请在每个列表项前面添加破折号 -、星号 * 或加号 + 。缩进一个或多个列表项可创建嵌套列表。 Markdown语法 HTML 预览效果 - First item- Second item- Third item- Indented item- Indenteditem item- Fourth item &lt;ul&gt;&lt;li&gt;First item&lt;&#x2F;li&gt;&lt;li&gt;Second item&lt;&#x2F;li&gt;&lt;li&gt;Third item&lt;ul&gt;&lt;li&gt;Indented item&lt;&#x2F;li&gt;&lt;li&gt;Indenteditem&lt;&#x2F;li&gt;&lt;&#x2F;ul&gt;&lt;&#x2F;li&gt;&lt;li&gt;Fourth item&lt;&#x2F;li&gt;&lt;&#x2F;ul&gt; First itemSecond itemThird itemIndented itemIndenteditemFourth item 在列表中嵌套其他元素 要在保留列表连续性的同时在列表中添加另一种元素，请将该元素缩进四个空格或一个制表符，如下例所示： 此处只给出代码块示意 1234567891. Open the file.2. Find the following code block on line 21: &lt;html&gt; &lt;head&gt; &lt;title&gt;Test&lt;/title&gt; &lt;/head&gt;3. Update the title to match the name of your website. 效果如下： Open the file. Find the following code block on line 21: &lt;html&gt; &lt;head&gt; &lt;title&gt;Test&lt;/title&gt; &lt;/head&gt; Update the title to match the name of your website. Markdown 代码语法 要将单词或短语表示为代码，请将其包裹在反引号 ` 中。 注意： 如果你要表示为代码的单词或短语中包含一个或多个反引号，则可以通过将单词或短语包裹在双反引号``中。 代码块 要创建代码块，请将代码块的每一行缩进至少四个空格或一个制表符。1234&lt;html&gt; &lt;head&gt; &lt;/head&gt;&lt;/html&gt; 注意： 要创建不用缩进的代码块，请使用 围栏式代码块 你可以在代码块之前和之后的行上使用三个反引号```或三个波浪号~~~。 `&#96;&#96;{“firstName”: “John”, “lastName”: “Smith”, “age”: 25}`&#96;&#96; 语法高亮 你可以在代码块的反引号```或波浪号~~~旁边指定一种语言。 `&#96;&#96;yml{“firstName”: “John”, “lastName”: “Smith”, “age”: 25}`&#96;&#96; 要创建分隔线，请在单独一行上使用三个或多个星号***、破折号---或下划线___，并且不能包含其他内容。 注意： 为了兼容性，请在分隔线的前后均添加空白行。 Markdown 链接语法 链接文本放在中括号内，链接地址放在后面的括号中，链接title可选。 超链接Markdown语法代码：[超链接显示名](超链接地址 &quot;超链接title&quot;) 对应的HTML代码：&lt;a href=&quot;超链接地址&quot; title=&quot;超链接title&quot;&gt;超链接显示名&lt;/a&gt; 例如：这是一个链接 [Markdown语法](https://markdown.com.cn)。 这是一个链接 Markdown语法。 Markdown 图片语法 要添加图像，请使用感叹号!, 然后在方括号增加替代文本，图片链接放在圆括号里，括号里的链接后可以增加一个可选的图片标题文本。 插入图片Markdown语法代码：![图片alt](图片链接 &quot;图片title&quot;)。 对应的HTML代码：&lt;img src=&quot;图片链接&quot; alt=&quot;图片alt&quot; title=&quot;图片title&quot;&gt; 例如 ：![图片](https://s2.loli.net/2023/05/15/JSXVAt48D9ZHwox.jpg &quot;Spider Man&quot;) 图片链接 给图片增加链接，请将图像的Markdown 括在方括号中，然后将链接添加在圆括号中。 [![图片](https://s2.loli.net/2023/05/15/JSXVAt48D9ZHwox.jpg &quot;Spider Man&quot;)](https://wallhaven.cc/w/pko8lm) Markdown 转义字符语法: 详细的转义字符语法建议参考Markdown 转义字符语法 | Markdown 官方教程 Markdown 内嵌 HTML 标签 由于本人并未学习过HTML，因此此处不再详述。 对于 Markdown 涵盖范围之外的标签，都可以直接在文件里面用 HTML 本身。如需使用 HTML，不需要额外标注这是 HTML 或是 Markdown，只需 HTML 标签添加到 Markdown 文本中即可。 行级內联标签 HTML 的行级內联标签如 &lt;span&gt;、&lt;cite&gt;、&lt;del&gt; 不受限制，可以在 Markdown 的段落、列表或是标题里任意使用。 区块标签 区块元素──比如 &lt;div&gt;、&lt;table&gt;、&lt;pre&gt;、&lt;p&gt; 等标签，必须在前后加上空行，以便于内容区分。 Markdown 表格 要添加表格，请使用三个或多个连字---创建每列的标题，并使用管道|分隔每列。你也可以选择在表的任一端添加管道。 Tip: 快速使用连字符和管道创建表，尝试使用此工具Markdown Tables Generator。 1234| Syntax | Description || ----------- | ----------- || Header | Title || Paragraph | Text | Syntax Description Header Title Paragraph Text 对齐 你可以通过在标题行中的连字符的左侧，右侧或两侧添加冒号:，将列中的文本对齐到左侧，右侧或中心。1234| Syntax | Description | Test Text || :--- | :----: | ---: || Header | Title | Here&#x27;s this || Paragraph | Text | And more | Syntax Description Test Text Header Title Here’s this Paragraph Text And more 更多规则请参照Markdown 表格 | Markdown 官方教程 Markdown 脚注 脚注可以为文档添加注释和参考，而不会使文档正文混乱。要创建脚注参考，请在方括号[^1]内添加插入符号和标识符。在括号内使用另一个插入符号和数字添加脚注，并用冒号和文本[^1]: My footnote. 注意： 标识符可以是数字或单词，但不能包含空格或制表符。 123This is a identifier[^footnote][^footnote]:This is the identifier&#x27;s footnote. This is a identifier[^footnote] [^footnote]:This is the identifier’s footnote. markdown 删除线 你可以通过在单词中心放置一条水平线来删除单词。结果看起来像这样。此功能使您可以指示某些单词是一个错误，要从文档中删除。若要删除单词，请在单词前后使用两个波浪号~~。 Markdown 任务列表语法 任务列表使你可以创建带有复选框的项目列表。在支持任务列表的Markdown应用程序中，复选框将显示在内容旁边。要创建任务列表，请在任务列表项之前添加破折号-和方括号[ ]，并在[ ]前面加上空格。要选择一个复选框，请在方括号[x]之间添加 x 。 123- [x] Write the press release- [ ] Update the website- [ ] Contact the media Write the press release Update the website Contact the media Markdown 使用 Emoji 表情 有两种方法可以将表情符号添加到Markdown文件中：将表情符号复制并粘贴到Markdown格式的文本中，或者键入_emoji shortcodes_ 在大多数情况下，您可以简单地从Emojipedia 等来源复制表情符号并将其粘贴到文档中。 Tip: 如果您使用的是静态网站生成器，请确保将HTML页面编码为UTF-8。 123去露营了！ :tent: 很快回来。真好笑！ :joy: 去露营了！ ⛺️ 很快回来。 真好笑！ 😂 注意： 你可以使用此表情符号简码列表，但请记住，表情符号简码因应用程序而异。 本篇文章到这里就结束啦~ Markdown语法的使用还得在日常使用中多多熟悉，感谢您的阅读！","categories":[{"name":"tool","slug":"tool","permalink":"https://aeonjh.top/categories/tool/"}],"tags":[{"name":"Markdown","slug":"Markdown","permalink":"https://aeonjh.top/tags/Markdown/"}]}],"categories":[{"name":"study","slug":"study","permalink":"https://aeonjh.top/categories/study/"},{"name":"tool","slug":"tool","permalink":"https://aeonjh.top/categories/tool/"}],"tags":[{"name":"JSON","slug":"JSON","permalink":"https://aeonjh.top/tags/JSON/"},{"name":"C","slug":"C","permalink":"https://aeonjh.top/tags/C/"},{"name":"Markdown","slug":"Markdown","permalink":"https://aeonjh.top/tags/Markdown/"}]}